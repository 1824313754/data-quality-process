# 动态编译业务设计说明

## 核心需求

实现动态编译功能，支持3种规则变更场景：
1. **删除规则** - 从规则引擎中移除不再需要的规则
2. **修改规则** - 重新编译并替换已有规则
3. **新增规则** - 编译新规则并添加到引擎

## 设计架构

### 核心组件

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   RuleProcessor │───▶│   RuleService   │───▶│  DynamicCompiler│
│   (定时调度)     │    │   (变更检测)     │    │   (代码编译)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   RuleEngine    │    │  RuleChanges    │    │   Class对象     │
│   (规则执行)     │    │  (变更信息)     │    │   (编译结果)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 关键类说明

#### 1. RuleService (核心业务逻辑)
- **职责**: 检测规则变更，执行增量更新
- **关键方法**:
  - `updateRules()`: 增量更新规则
  - `detectChanges()`: 检测规则变更
  - `isRuleModified()`: 判断规则是否被修改

#### 2. RuleEngine (规则管理)
- **新增方法**:
  - `removeRule()`: 删除指定规则
  - `hasRule()`: 检查规则是否存在
  - `getRule()`: 获取规则实例

#### 3. RuleChanges (变更信息)
- **职责**: 记录规则的增删改变更
- **属性**:
  - `deletedRules`: 删除的规则ID列表
  - `addedOrModifiedRules`: 新增或修改的规则列表

#### 4. RuleUpdateResult (更新结果)
- **职责**: 统计更新结果
- **属性**:
  - `addedCount`: 新增规则数量
  - `modifiedCount`: 修改规则数量
  - `deletedCount`: 删除规则数量
  - `errorCount`: 错误数量

## 业务流程

### 1. 初始化流程
```
RuleProcessor.open()
    ├── 创建RuleEngine和RuleService
    ├── 调用initialLoadRules()进行全量加载
    └── 启动定时任务，定期调用updateRules()
```

### 2. 增量更新流程
```
RuleService.updateRules()
    ├── 从数据库加载最新规则
    ├── 调用detectChanges()检测变更
    ├── 处理删除的规则
    │   └── ruleEngine.removeRule()
    ├── 处理新增/修改的规则
    │   ├── 如果是修改：先removeRule()
    │   ├── 调用DynamicCompiler.compile()编译
    │   └── 调用ruleEngine.registerRule()注册
    └── 返回RuleUpdateResult
```

### 3. 变更检测逻辑
```
detectChanges()
    ├── 检测删除：本地有但数据库没有的规则
    ├── 检测新增：数据库有但本地没有的规则
    └── 检测修改：比较updateTime判断是否变更
```

## 三种变更场景处理

### 场景1: 删除规则
```sql
-- 数据库操作
UPDATE rule_class SET status = 0 WHERE id = 'RULE_ID';
-- 或者
DELETE FROM rule_class WHERE id = 'RULE_ID';
```

**系统处理**:
1. `detectChanges()`发现本地快照中有但数据库中没有的规则
2. 调用`ruleEngine.removeRule(ruleId)`从引擎中移除
3. 从本地快照中删除该规则记录

### 场景2: 修改规则
```sql
-- 数据库操作
UPDATE rule_class 
SET source_code = '新的源代码', 
    update_time = NOW() 
WHERE id = 'RULE_ID';
```

**系统处理**:
1. `detectChanges()`通过比较`updateTime`发现规则被修改
2. 调用`ruleEngine.removeRule(ruleId)`移除旧版本
3. 调用`DynamicCompiler.compile()`编译新代码
4. 调用`ruleEngine.registerRule()`注册新规则
5. 更新本地快照

### 场景3: 新增规则
```sql
-- 数据库操作
INSERT INTO rule_class (id, name, source_code, ...) 
VALUES ('NEW_RULE_ID', 'NewRule', '源代码', ...);
```

**系统处理**:
1. `detectChanges()`发现数据库中有但本地快照中没有的规则
2. 调用`DynamicCompiler.compile()`编译代码
3. 调用`ruleEngine.registerRule()`注册规则
4. 添加到本地快照

## 优势特点

### 1. 增量更新
- 只处理变更的规则，不影响其他规则
- 避免全量重新加载的性能开销

### 2. 原子操作
- 每个规则的更新都是原子的
- 失败的规则不影响其他规则的更新

### 3. 无服务中断
- 更新过程中服务持续可用
- 不存在规则引擎为空的时间窗口

### 4. 详细监控
- 提供详细的更新统计信息
- 区分新增、修改、删除操作

### 5. 错误隔离
- 单个规则编译失败不影响其他规则
- 提供详细的错误信息和日志

## 使用示例

### 监控日志示例
```
2025-07-09 10:00:00 INFO  - 规则更新完成 - RuleUpdateResult{新增:2, 修改:1, 删除:1, 错误:0}, 当前规则数: 25
2025-07-09 10:01:00 DEBUG - 无规则变更
2025-07-09 10:02:00 INFO  - 新增规则: NEW_SOC_RULE
2025-07-09 10:02:00 INFO  - 修改规则: EXISTING_VOLTAGE_RULE
2025-07-09 10:02:00 INFO  - 删除规则: OLD_TEMPERATURE_RULE
```

### 错误处理示例
```
2025-07-09 10:03:00 ERROR - 创建规则实例失败: INVALID_RULE - 编译失败:
第 15 行, 位置 25: 找不到符号 BatteryDataX
2025-07-09 10:03:00 WARN  - 规则更新过程中发生错误，错误数量: 1
```

这个设计确保了动态编译功能的高效、稳定和可监控。
