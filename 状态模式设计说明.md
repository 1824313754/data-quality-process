# 策略模式在动态编译中的应用

## 设计思路

采用**枚举策略模式**，将处理逻辑封装在枚举中，实现简洁而优雅的策略模式：

### 设计原则
- **策略封装**: 每种变更类型都有自己的处理策略
- **多态实现**: 利用枚举的抽象方法实现多态
- **简洁高效**: 避免额外的类和接口，直接在枚举中实现策略

## 策略模式架构

```
┌─────────────────┐
│  RuleService    │
│                 │
│ ┌─────────────┐ │
│ │updateRules()│ │
│ │             │ │
│ │ changeType  │ │
│ │   .handle() │ │
│ └─────────────┘ │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐    ┌─────────────────────┐
│ RuleChangeType  │───▶│ RuleChangeStrategy  │
│   (Context)     │    │    (Interface)      │
│                 │    └─────────┬───────────┘
│ NEW(strategy)   │              │
│ MODIFIED(...)   │              │
│ DELETED(...)    │              ▼
│ UNCHANGED(...)  │    ┌─────────────────────┐
└─────────────────┘    │  Concrete Strategy  │
                       │                     │
                       │ ┌─────────────────┐ │
                       │ │NewRuleStrategy  │ │
                       │ └─────────────────┘ │
                       │ ┌─────────────────┐ │
                       │ │ModifiedRule...  │ │
                       │ └─────────────────┘ │
                       │ ┌─────────────────┐ │
                       │ │DeletedRule...   │ │
                       │ └─────────────────┘ │
                       │ ┌─────────────────┐ │
                       │ │UnchangedRule... │ │
                       │ └─────────────────┘ │
                       └─────────────────────┘
```

## 核心组件

### 1. 策略接口 (RuleChangeStrategy)
```java
public interface RuleChangeStrategy {
    void handle(RuleEngine ruleEngine, RuleInfo ruleInfo, String ruleId,
                RuleService ruleService, RuleUpdateResult result);
}
```

### 2. 具体策略实现
- **NewRuleStrategy**: 新增规则策略
- **ModifiedRuleStrategy**: 修改规则策略
- **DeletedRuleStrategy**: 删除规则策略
- **UnchangedRuleStrategy**: 无变更策略

### 3. 策略上下文 (RuleChangeType)
```java
public enum RuleChangeType {
    NEW("新增", new NewRuleStrategy()),
    MODIFIED("修改", new ModifiedRuleStrategy()),
    DELETED("删除", new DeletedRuleStrategy()),
    UNCHANGED("无变更", new UnchangedRuleStrategy());

    public void handle(...) {
        strategy.handle(...);  // 委托给具体策略
    }
}
```

### 4. 核心处理逻辑 (RuleService)
```java
public RuleUpdateResult updateRules(RuleEngine ruleEngine) {
    // 检测变更
    Map<String, RuleChangeType> ruleChanges = detectAllRuleChanges(latestRules);

    // 委托给策略处理
    for (Map.Entry<String, RuleChangeType> entry : ruleChanges.entrySet()) {
        RuleChangeType changeType = entry.getValue();
        changeType.handle(ruleEngine, ruleInfo, ruleId, this, result);
    }
}
```

## 业务流程

### 重构后的处理流程
```
RuleService.updateRules()
    ├── 1. 加载最新规则
    ├── 2. 检测所有规则变更状态
    ├── 3. 遍历每个规则
    │   ├── 获取变更类型
    │   ├── 通过工厂获取处理器
    │   ├── 执行状态处理器
    │   └── 统计处理结果
    └── 4. 返回更新结果
```

### 状态检测逻辑
```java
private Map<String, RuleChangeType> detectAllRuleChanges(Map<String, RuleInfo> latestRules) {
    // 检测删除：本地有但数据库没有
    // 检测新增：数据库有但本地没有  
    // 检测修改：updateTime不同
    // 检测无变更：updateTime相同
}
```

## 优势对比

### 重构前的问题
```java
// 大量if-else逻辑，难以维护
if (ruleEngine.hasRule(ruleInfo.getId())) {
    // 修改逻辑
    ruleEngine.removeRule(ruleInfo.getId());
    // ... 编译注册逻辑
} else {
    // 新增逻辑  
    // ... 编译注册逻辑
}
// 删除逻辑在另一个循环中
```

### 重构后的优势
```java
// 清晰的状态驱动
RuleChangeHandler handler = RuleChangeHandlerFactory.getHandler(changeType);
RuleProcessResult result = handler.handle(ruleEngine, ruleInfo, ruleId, this);
```

## 设计优势

### 1. **单一职责原则**
- 每个处理器只负责一种状态的处理
- RuleService只负责协调，不包含具体处理逻辑

### 2. **开闭原则**
- 新增状态类型只需添加新的处理器
- 不需要修改现有代码

### 3. **可测试性**
- 每个处理器可以独立测试
- 状态检测逻辑独立可测试

### 4. **可扩展性**
- 容易添加新的规则状态（如SUSPENDED、ARCHIVED等）
- 容易修改单个状态的处理逻辑

### 5. **可读性**
- 代码结构清晰，易于理解
- 状态转换逻辑明确

## 使用示例

### 添加新状态
```java
// 1. 添加枚举值
public enum RuleChangeType {
    // ... 现有状态
    SUSPENDED("暂停");
}

// 2. 实现处理器
public class SuspendedRuleHandler implements RuleChangeHandler {
    @Override
    public RuleProcessResult handle(...) {
        // 暂停规则的处理逻辑
    }
}

// 3. 注册到工厂
static {
    HANDLERS.put(RuleChangeType.SUSPENDED, new SuspendedRuleHandler());
}
```

### 监控日志
```
2025-07-09 10:00:00 INFO  - 开始处理新增规则: NEW_SOC_RULE
2025-07-09 10:00:01 INFO  - 新增规则成功: NEW_SOC_RULE
2025-07-09 10:00:02 INFO  - 开始处理修改规则: VOLTAGE_RULE
2025-07-09 10:00:02 DEBUG - 移除旧版本规则: VOLTAGE_RULE
2025-07-09 10:00:03 INFO  - 修改规则成功: VOLTAGE_RULE
2025-07-09 10:00:04 INFO  - 开始处理删除规则: OLD_TEMP_RULE
2025-07-09 10:00:04 INFO  - 删除规则成功: OLD_TEMP_RULE
2025-07-09 10:00:05 INFO  - 规则更新完成 - 新增:1, 修改:1, 删除:1, 错误:0
```

这种设计使得动态编译业务更加清晰、可维护和可扩展。
